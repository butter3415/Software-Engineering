package week02;

public class week02_1 {

}
/*
Design Principle
1. 변화하는 부분과 변화하지 않는 부분을 분리하라.
-> '캡슐화', 코드 변경 과정에서 의도치 않은 일 줄이면서 시스템 유연성 향상 가능

2. 추상, 인터페이스에 맞춰서 프로그래밍 하라. /// 구체 구현(일반 클래스)에 기반하여 코딩하지 말라.

Duck - 컴포지션
duck has a quackBehavior() - 연관관계
MallardDuck - 컴포지션 관계 (Duck 만들어지면서 quack, fly 같이 만들어지니까) // 조립은 어그리에이션

3. 상속보다는 연관관계로 프로그래밍 하라. (is a 보다는 has a)

- [STRATEGY PATTERN - 전략 패턴]

The Strategy Pattern - 독립적으로 다른 패턴을 사용할 수 있도록



*/


/*
2023 software git 확인
s : 단일 책임의 원칙 (single)
=> 클래스 하나에 작성하면 단일책임의 원칙 위배
    기능별로 클래스 따로 작성

----------------------------------------------------------------------
o : 개방 폐쇄의 원칙
=> 확장에 열려있고, 수정에 닫혀있다.

추상(abstract) : 상속 받아서 사용, 객체 생성 X
private - getter, setter 사용 필요
protected - 상속받은 경우에는 .-- 로 사용 가능

abstract method -> 자식 객체에서 반드시 오버라이드 해야함
확장이 편함
피카츄, 리자드 뿐만 아니라 뮤, 개굴닌자 추가하려해도 다른 내용은 수정 안해도됨

----------------------------------------------------------------------
l : 리스코프 치환 원칙
=> 부모 클래스 객체 자리에 자식 클래스 객체도 호환 가능

----------------------------------------------------------------------
i : 인터페이스 분리의 원칙
=> 인터페이스 분리하면
파이리일때는 날개가 없지만 리자몽때는 날개가 생겨서 날라갈 수 있게 된다.
- implements AttackablePokemon, FlyablePokemon{ } 가능

----------------------------------------------------------------------
d : 의존성 역전의 원칙

*/